<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js Terrain with Tank</title>
    <style>
        body { margin: 0; }
        canvas { display: block; cursor: pointer; }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 24px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="overlay">Press c to play</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { OrbitControls } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/controls/OrbitControls.js';
        import { TextureLoader } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/loaders/TextureLoader.js';

        // Basic setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable damping (inertia)
        controls.dampingFactor = 0.05; // Damping factor
        controls.target.set(0, 0.5, 0); // Camera looks at the tank
        controls.enablePan = false; // Disable panning

        // Load textures
        const loader = new TextureLoader();
        const terrainTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        const leavesTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        const tankTexture = loader.load('https://threejs.org/examples/textures/crate.gif');

        // Add a ground plane with height data
        const size = 100;
        const divisions = 10;
        const planeGeometry = new THREE.PlaneGeometry(size, size, divisions, divisions);
        const planeMaterial = new THREE.MeshLambertMaterial({ map: terrainTexture });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
        scene.add(plane);

        // Generate hills by modifying plane vertices
        function generateHills() {
            const heightData = [];
            for (let i = 0; i <= divisions; i++) {
                heightData[i] = [];
                for (let j = 0; j <= divisions; j++) {
                    const height = Math.random() * 3; // Reduced the maximum height to 3
                    heightData[i][j] = height;
                    plane.geometry.attributes.position.setZ(i * (divisions + 1) + j, height);
                }
            }
            plane.geometry.attributes.position.needsUpdate = true;
            plane.geometry.computeVertexNormals();
            return heightData;
        }
        const heightData = generateHills();

        // Add trees
        function addTrees() {
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 32);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color for the trunk
            const leavesGeometry = new THREE.ConeGeometry(2, 5, 32);
            const leavesMaterial = new THREE.MeshLambertMaterial({ map: leavesTexture });

            for (let i = 0; i < 10; i++) {
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                
                const x = Math.random() * size - size / 2;
                const z = Math.random() * size - size / 2;
                const y = getHeightAt(x, z, heightData);

                trunk.position.set(x, y + 2.5, z);
                leaves.position.set(x, y + 5, z);

                scene.add(trunk);
                scene.add(leaves);
            }
        }
        addTrees();

        // Add rocks
        function addRocks() {
            const rockGeometry = new THREE.DodecahedronGeometry(2);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });

            for (let i = 0; i < 5; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                const x = Math.random() * size - size / 2;
                const z = Math.random() * size - size / 2;
                const y = getHeightAt(x, z, heightData);

                rock.position.set(x, y + 1, z);
                scene.add(rock);
            }
        }
        addRocks();

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        scene.add(light);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Add a tank
        const tankGeometry = new THREE.BoxGeometry(1, 1, 2);
        const tankMaterial = new THREE.MeshLambertMaterial({ map: tankTexture });
        const tank = new THREE.Mesh(tankGeometry, tankMaterial);
        tank.position.y = getHeightAt(tank.position.x, tank.position.z, heightData) + 0.5;
        scene.add(tank);

        // Camera settings
        const cameraOffset = new THREE.Vector3(0, 5, -10);

        // Tank movement
        let moveForward = false;
        let moveBackward = false;
        let rotateLeft = false;
        let rotateRight = false;
        let startGameFlag = false;

        function handleKeyDown(event) {
            switch (event.key.toLowerCase()) { // Convert the key to lowercase
                case 'w':
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'a':
                    rotateLeft = true;
                    break;
                case 'c':
                    startGameFlag = true;
                    break;
                case 'd':
                    rotateRight = true;
                    break;
            }
        }

        function handleKeyUp(event) {
            switch (event.key.toLowerCase()) { // Convert the key to lowercase
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'a':
                    rotateLeft = false;
                    break;
                case 'c':
                    if (startGameFlag) {
                        startGame();
                    }
                    break;
                case 'd':
                    rotateRight = false;
                    break;
            }
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Get height at a specific position
        function getHeightAt(x, z, heightData) {
            const halfSize = size / 2;
            const i = Math.floor((x + halfSize) / size * divisions);
            const j = Math.floor((z + halfSize) / size * divisions);
            if (i < 0 || i >= heightData.length || j < 0 || j >= heightData[i].length) {
                return 0; // Return a default height if out of bounds
            }
            return heightData[i][j];
        }

        // Check if the tank is outside the map boundaries
        function checkOutOfBounds() {
            const halfSize = size / 2;
            if (tank.position.x < -halfSize || tank.position.x > halfSize || tank.position.z < -halfSize || tank.position.z > halfSize) {
                tank.position.set(0, getHeightAt(0, 0, heightData) + 0.5, 0);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Pointer lock setup
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === renderer.domElement) {
                console.log('Pointer locked');
                document.addEventListener('mousemove', updateCameraRotation, false);
            } else {
                console.log('Pointer unlocked');
                document.removeEventListener('mousemove', updateCameraRotation, false);
            }
        });

        function updateCameraRotation(event) {
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            // Adjust the controls rotation based on mouse movement
            controls.rotateLeft(movementX * 0.002);
            controls.rotateUp(movementY * 0.002);
        }

        // Start the game when 'c' key is pressed
        function startGame() {
            document.getElementById('overlay').style.display = 'none';
            animate();
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (moveForward) {
                tank.translateZ(-0.1);
            }
            if (moveBackward) {
                tank.translateZ(0.1);
            }
            if (rotateLeft) {
                tank.rotation.y += 0.05;
            }
            if (rotateRight) {
                tank.rotation.y -= 0.05;
            }

            // Adjust tank height based on terrain
            tank.position.y = getHeightAt(tank.position.x, tank.position.z, heightData) + 0.5;

            // Check if the tank is out of bounds
            checkOutOfBounds();

            // Update camera position to follow the tank
            controls.target.set(tank.position.x, tank.position.y, tank.position.z);
            controls.update();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
