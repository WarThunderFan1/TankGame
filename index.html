<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js Terrain with Tank</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/jsm/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/jsm/loaders/TextureLoader.js"></script>
    <script>
        // Basic setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Pointer Lock Controls
        const controls = new THREE.PointerLockControls(camera, document.body);
        controls.lock();
        scene.add(controls.getObject());

        // Load textures
        const loader = new THREE.TextureLoader();
        const terrainTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        const leavesTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        const tankTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');

        // Add a ground plane with height data
        const size = 100;
        const divisions = 10;
        const planeGeometry = new THREE.PlaneGeometry(size, size, divisions, divisions);
        const planeMaterial = new THREE.MeshLambertMaterial({ map: terrainTexture });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
        scene.add(plane);

        // Generate hills by modifying plane vertices
        function generateHills() {
            const heightData = [];
            const position = plane.geometry.attributes.position;
            for (let i = 0; i <= divisions; i++) {
                heightData[i] = [];
                for (let j = 0; j <= divisions; j++) {
                    const height = Math.random() * 3; // Reduced the maximum height to 3
                    heightData[i][j] = height;
                    const index = i * (divisions + 1) + j;
                    position.setZ(index, height);
                }
            }
            position.needsUpdate = true;
            plane.geometry.computeVertexNormals();
            return heightData;
        }
        const heightData = generateHills();

        // Add GridHelper
        const gridHelper = new THREE.GridHelper(size, divisions);
        scene.add(gridHelper);

        // Add trees
        function addTrees() {
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 32);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown color for the trunk
            const leavesGeometry = new THREE.ConeGeometry(2, 5, 32);
            const leavesMaterial = new THREE.MeshLambertMaterial({ map: leavesTexture });

            for (let i = 0; i < 10; i++) {
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                
                const x = Math.random() * size - size / 2;
                const z = Math.random() * size - size / 2;
                const y = getHeightAt(x, z, heightData);

                trunk.position.set(x, y + 2.5, z);
                leaves.position.set(x, y + 5, z);

                scene.add(trunk);
                scene.add(leaves);
            }
        }
        addTrees();

        // Add rocks
        function addRocks() {
            const rockGeometry = new THREE.DodecahedronGeometry(2);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });

            for (let i = 0; i < 5; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                const x = Math.random() * size - size / 2;
                const z = Math.random() * size - size / 2;
                const y = getHeightAt(x, z, heightData);

                rock.position.set(x, y + 1, z);
                scene.add(rock);
            }
        }
        addRocks();

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        scene.add(light);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Add a tank
        const tankGeometry = new THREE.BoxGeometry(1, 1, 2);
        const tankMaterial = new THREE.MeshLambertMaterial({ map: tankTexture });
        const tank = new THREE.Mesh(tankGeometry, tankMaterial);
        tank.position.set(0, getHeightAt(0, 0, heightData) + 0.5, 0);
        scene.add(tank);

        // Add a basic box for debugging
        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(2, 1, 2);
        scene.add(box);

        // Add a directional light helper
        const lightHelper = new THREE.DirectionalLightHelper(light, 5);
        scene.add(lightHelper);

        // Camera settings
        const cameraOffset = new THREE.Vector3(0, 5, -10);
        camera.position.set(0, 10, 10);
        camera.lookAt(0, 0, 0);

        // Tank movement
        let moveForward = false;
        let moveBackward = false;
        let rotateLeft = false;
        let rotateRight = false;

        function handleKeyDown(event) {
            switch (event.key) {
                case 'w':
                    moveForward = true;
                    break;
                case 's':
                    moveBackward = true;
                    break;
                case 'a':
                    rotateLeft = true;
                    break;
                case 'd':
                    rotateRight = true;
                    break;
            }
        }

        function handleKeyUp(event) {
            switch (event.key) {
                case 'w':
                    moveForward = false;
                    break;
                case 's':
                    moveBackward = false;
                    break;
                case 'a':
                    rotateLeft = false;
                    break;
                case 'd':
                    rotateRight = false;
                    break;
            }
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // Get height at a specific position
        function getHeightAt(x, z, heightData) {
            const halfSize = size / 2;
            const i = Math.floor((x + halfSize) / size * divisions);
            const j = Math.floor((z + halfSize) / size * divisions);
            return heightData[i][j];
        }

        // Check if the tank is outside the map boundaries
        function checkOutOfBounds() {
            const halfSize = size / 2;
            if (tank.position.x < -halfSize || tank.position.x > halfSize || tank.position.z < -halfSize || tank.position.z > halfSize) {
                tank.position.set(0, getHeightAt(0, 0, heightData) + 0.5, 0);
            }
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            if (moveForward) {
                tank.translateZ(-0.1);
            }
            if (moveBackward) {
                tank.translateZ(0.1);
            }
            if (rotateLeft) {
                tank.rotation.y += 0.05;
            }
            if (rotateRight) {
                tank.rotation.y -= 0.05;
            }

            // Adjust tank height based on terrain
            tank.position.y = getHeightAt(tank.position.x, tank.position.z, heightData) + 0.5;

            // Check if the tank is out of bounds
            checkOutOfBounds();

            // Update camera position to follow the tank
            const relativeCameraOffset = cameraOffset.clone().applyMatrix4(tank.matrixWorld);
            camera.position.lerp(relativeCameraOffset, 0.1);
            camera.lookAt(tank.position);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
